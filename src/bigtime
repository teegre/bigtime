#! /usr/bin/env bash

##  _   _____     _
## |_)o/__ |o|\/||_
## |_)|\_| |||  ||_
## BiGTiME

##  _ _  _  _
## / / \|_)|_
## \_\_/| \|_
## CORE

## CONFIG
declare -r __path_config="/etc/bigtime"

## ASSETS
declare -r __path_digits="$__path_config/digits"

declare -r __path_digits_custom="$HOME/.config/bigtime"
declare -r __f_digits_default="$__path_digits/standard.digits"

declare -r __path_snd="$__path_config/snd"
declare -r __f_snd_welcome="$__path_snd/welcome.wav"
declare -r __f_snd_beep="$__path_snd/beep.wav"
declare -r __f_snd_alarm="$__path_snd/alarm.wav"
declare -r __f_snd_timer="$__path_snd/timer.wav"
declare -r __f_snd_key="$__path_snd/key.wav"
declare -r __f_snd_digit="$__path_snd/digit.wav"
declare -r __f_snd_yes="$__path_snd/confirm.wav"
declare -r __f_snd_err="$__path_snd/error.wav"
declare -r __f_snd_quit="$__path_snd/quit.wav"

declare -r __path_icn="$__path_config/icn"
declare -r __f_icn_alarm="$__path_icn/alarm.png"
declare -r __f_icn_timer="$__path_icn/timer.png"

## VARIABLES

# GEOMETRY
declare -i __clock_h __clock_w
declare -i __digit_h __digit_w __sep_w
declare -i __pos_y __pos_x

# COLORS 
# shellcheck disable=SC2155
declare -ir __color_count=$(tput colors)
declare -ar __colors=(39 38 44 43 49 48 84 83 119 118 154 148 184 178 214 208 209 203 204 198 199 163 164 128 129 93 99 63 69 33)
declare -i __color_idx
declare -i __color_fg
declare -i __color_bg

((__color_idx=RANDOM%(${#__colors[@]}-1)))

# DISPLAY
declare -i __display=1
declare -A __i

# TIME/DATE
declare -r __format="%I:%p:%H:%M:%S:%a:%d:%m:%z"

## FUNCTIONS

# UTILS

_err() ( >&2 echo -e "$progname: $1" )

_help() {
cat << 'EOB' >&2
BIGTIME - customizable digital clock

USAGE:
bigtime [OPTION [VALUE] ... OPTION [VALUE]]

OPTIONS:
    -s, --small-seconds
        Show seconds (normal size).
    -S, --big-seconds
        Show seconds (big size).
    -d, --date
        Show date.
    -f  Display time in 24h format.
    -z, --timezone
        Show timezone (i.e. +0200).
    -F, --foreground 0..N
        Set foreground color (override -n and -r options).
    -B, --background 0..N
        Set background color.
    -r, --rainbow
        Rainbow effect.
    -n, --random
        Random colors effect (use system 16 colors palette).
    -C, --list-colors
        Print available colors and exit.
    -b, --blink
        Blinking separators.
    -N, --no-separator
        Do not display separators (horizontal layout only).
    -v, --vertical
        Display clock vertically.
    -a, --alarm [H]H:MM [AM|am|PM|pm]
        Set daily alarm.
    -a, --alarm now
        Test alarm.
    -o, --snooze [M]M
        Set snooze duration in minutes (5-15).
        (Default is 9 minutes.)
    -i, --signal
        Hourly time signal.
    -t, --timer [H]H:MM
        Set timer.
    --file FILENAME
        Use a custom digits file (filename only)
    -w, --preview
        Display a preview of --file and exit.
    -l, --list-files
        Print available digits files and exit.
    -e, --edit FILENAME
        Create or edit a custom digits file.
    -q, --quiet
        Disable sound, alarm, timer, and hourly time signal.
    -h, --help
        Print this help message and exit
    -V, --version
        Print program version info and exit.

KEYS BINDINGS:
    a     - toggle daily alarm; set/confirm new alarm; disable snooze mode.
    i     - toggle hourly time signal
    j     - select next digit (setting mode)
    k     - select previous digit (setting mode)
    f     - toggle 24h format; toggle AM/PM (alarm setting mode).
    q     - exit program.
    R     - refresh screen.
    t     - toggle timer; set/confirm new timer.
    space - toggle display; stop; cancel (setting mode).

EOB
}

_version() ( echo "$PROGNAME version $__version" )

loc() ( tput cup "$@" )

_sync() {
  declare -i n=1
  local N
  while ((n!=0)); do
    N="${EPOCHREALTIME#*,}"
    n=${N:0:1}
    pause 0.0625
  done
  unset n
}

notify() {
  case $1 in
    --alarm) notify-send -u critical -i "$__f_icn_alarm" "$PROGNAME" "$2" ;;
    --timer) notify-send -i "$__f_icn_timer" "$PROGNAME" "$2"
  esac
}

play_sound() {
  [[ ${__o[q]} ]] && return
  case $1 in
    welcome) aplay --quiet "$__f_snd_welcome" & ;;
    key    ) aplay --quiet "$__f_snd_key" & ;;
    digit  ) aplay --quiet "$__f_snd_digit" & ;;
    alarm  ) aplay --quiet "$__f_snd_alarm" & ;;
    timer  ) aplay --quiet "$__f_snd_timer" & ;;
    beep   ) aplay --quiet "$__f_snd_beep" & ;;
    error  ) aplay --quiet "$__f_snd_err" & ;;
    confirm) aplay --quiet "$__f_snd_yes" & ;;
    quit   ) aplay --quiet "$__f_snd_quit" ;;
  esac
}

toggle_display() {
  [[ ${__o[q]} ]] && return 1

  [[ $_a_ring && ! $1 ]] && { unset _a_ring _a_ring_dur; unset __i_alarm; return 0; }
  [[ $_t_ring && ! $1 ]] && { reset_timer; ((__display!=3)) && return 0; }

  [[ ! ${__o[a]} && ! $_a_set && ! ${__o[t]} && ! $_t_set && ! $1 ]] && return 1

  __u_date=1

  ((__display==2)) && [[ ! $1 ]] && unset __i_alarm

  if [[ $_a_set || $_t_set ]] && [[ ! $1 ]]; then __display=4
  elif [[ $1 ]]; then __display=$1; else ((__display++)); fi

  ((__display==2)) && [[ ${__o[a]} || $_a_set ]] && {
    erase_clock_line 
    unset __i_alarm
    [[ $_a_set ]] && { __digit_sel=0; unset H1; }
    mode_display
    return 0
  }

  ((__display==2)) && [[ ! ${__o[a]} ]] && ((__display++))

  ((__display==3)) && [[ ${__o[t]} || $_t_set ]] && {
    erase_clock_line
    [[ ${__o[v]} ]] && erase_timer_line
    unset __i_timer S1 S2
    [[ $_t_set ]] && { __digit_sel=0; unset H1; }
    mode_display
    return 0
  }
  [[ $__display -gt 2 || $1 ]] && erase_clock_line
  __display=1
  __i_mode=1
  unset __i_alarm __i_timer
  [[ ${__o[b]} ]] && unset __separator
  [[ $_a_set ]] && cancel_alarm
  [[ $_t_set ]] && cancel_timer
  mode_display
  return 0
}

mode_display() {
  local y x mode
  case $__display in
    1) mode="TIME"  ;;
    2) if [[ $_a_set ]]; then mode="SET ALARM"; else mode="ALARM"; fi ;;
    3) if [[ $_t_set ]]; then mode="SET TIMER"; else mode="TIMER"; fi ;;
  esac
  ((y=__pos_y-1))
  [[ ${__o[v]} ]] && ((x=__pos_x))
  [[ ${__o[v]} ]] || ((x=__pos_x+__clock_w-${#mode}))
  random_color
  loc $((y)) $((x-(9-${#mode})))
  tput el
  loc $((y)) $((x))
  echo "$mode" | print_rainbow
  __i_mode=1
}

erase_display_line() {
  local y x
  ((y=__pos_y-1))
  [[ ${__o[v]} ]] && ((x=__pos_x))
  [[ ${__o[v]} ]] || ((x=__pos_x+__clock_w-9))
  loc $((y)) $((x))
  tput el
  unset __i_mode
}

##    _ _  _  _
##  // / \|_)|_
## / \_\_/| \|_
## /CORE

##  _ _    _  _
## / / \| / \|_)
## \_\_/|_\_/| \
## COLOR

set_color() {
  [[ $2 =~ ^[0-9]+$ ]] || return 1
  if (($2>=0 && $2<=__color_count-1)); then
    case $1 in
      --bg) __color_bg=$2 ;;
      --fg) __color_fg=$2
    esac
    [[ $__color_bg ]] &&
      [[ $__color_fg ]] &&
        ((__color_bg==__color_fg)) && return 1
    return 0
  else
    return 1
  fi
}

list_colors() {
  local term_w max_cols term_color col i on off
  term_w="$(tput cols)"
  ((max_cols=term_w<75?term_w/5-1:15))
  for ((i=0;i<__color_count;i++)); do
    on="$(tput setab $((i)))"
    if ((i==0)); then
      term_color="$(tput setaf $((__color_count-1)))"
    else
      term_color="$(tput setaf 0)"
    fi
    off="$(tput sgr0)"
    printf "%s%s %03d %s" "$on" "$term_color" "$i" "$off"
    ((col++))
    ((col>max_cols)) && { printf "\n"; col=0; }
  done
  echo
}

random_color() {
  [[ ! ${__o[r]} && ! ${__o[n]} ]] && return 1
  [[ ${__o[r]} ]] && ((__color_idx=__color_idx>${#__colors[@]}-2?0:__color_idx+1))
  [[ ${__o[r]} ]] && __color=${__colors[$__color_idx]}
  [[ ${__o[n]} ]] && ((__color=RANDOM%15+1))
  return 0
}

##    _ _    _  _
##  // / \| / \|_)
## / \_\_/|_\_/| \
## /COLOR

##  _    _
## |_o| |_
## | ||_|_
## FiLE

check_file() {
  [[ $1 =~ \.digits$ ]] && __f_digits="$1" || __f_digits="$1.digits"
  [[ $2 == "--edit" ]] && {
    [[ -a "$__path_digits/$__f_digits" ]] && {
      _err "error: cannot edit files in $__path_digits directory."
      exit 1
    }
    __f_digits="$__path_digits_custom/$__f_digits"
    [[ -a "$__f_digits" ]] && return 0 || return 1
  }
  if [[ ! -a "$__path_digits/$__f_digits" && ! -a "$__path_digits_custom/$__f_digits" ]]; then return 1
  elif [[ -a "$__path_digits/$__f_digits" ]]; then __f_digits="$__path_digits/$__f_digits"
  else __f_digits="$__path_digits_custom/$__f_digits"
  fi
  return 0
}

list_files() {
  local files
  files="$(
  (
    find "$__path_digits" -name "*.digits" 2> /dev/null
    find "$__path_digits_custom" -name "*.digits" 2> /dev/null
  ) )"
  [[ ! $files ]] && return 1
  echo -e "$files"
  return 0
}

preview_file() {
  local y x term_h i
  term_h="$(tput lines)"

  # shellcheck disable=SC2162
  IFS=";" read -sdR -p $'\E[6n' y x
  y="${y#*[}"; x="${x#*[}" # cursor position
  ((y--))
  ((x+=2))
  ((y+__digit_h>term_h)) && {
    for ((i=0;i<__digit_h;i++)); do echo; done
    ((y=term_h-__digit_h-1))
  }

  if [[ ${__color_bg} ]]; then
    tput setab "$__color_bg"
    for ((i=y;i<y+__digit_h;i++)); do
      loc $((i)) 0; tput el
    done
  fi

  [[ $__color_fg ]] && tput setaf "$__color_fg"

  _split_time "$(LC_TIME=C _time "%I:%p:%H:%M")"
  local p h m s h1 h2 m1 m2
  if  [[ ! ${__o[f]} ]]; then
    h="${__T_timedate[0]}"
    p="${__T_timedate[1]}"
    case $p in
      AM) p="${__i[am]}" ;;
      PM) p="${__i[pm]}"
    esac
  else
    h="${__T_timedate[2]}"
  fi
  m="${__T_timedate[3]}"

  h1="${h:0:1}"
  h2="${h:1:1}"
  m1="${m:0:1}"
  m2="${m:1:1}"

  [[ ${__o[n]} || ${__o[r]} ]] && random_color
  loc $((y))   $((x-2)); tput el; echo "${__i[i]}" | print_rainbow

  [[ ${__o[n]} || ${__o[r]} ]] && random_color
  loc $((y+1)) $((x-2)); tput el; echo "${__i[a]}" | print_rainbow

  [[ ${__o[n]} || ${__o[r]} ]] && random_color
  loc $((y+2)) $((x-2)); tput el; echo "${__i[t]}" | print_rainbow

  print_digit $((y)) $((x)) "$h1"
  ((x+=__digit_w+1))
  print_digit $((y)) $((x)) "$h2"
  ((x+=__digit_w))

  [[ ! ${__o[N]} ]] && {
    print_separator $((y)) $((x))
    ((x+=__sep_w))
  }

  [[ ${__o[N]} || ${__o[v]} ]] && ((x++))

  print_digit $((y)) $((x)) "$m1"
  ((x+=__digit_w+1))
  print_digit $((y)) $((x)) "$m2"
  ((x+=__digit_w+1))
  
  [[ $p ]] && {
    loc $((y+__clock_h-1)) $((x))
    echo "$p" | print_rainbow
  }

  [[ $__color_fg || $__color_bg ]] && tput sgr0
  echo
}

read_param() {
  local __p __v __a
  __p="$1"
  while read -r __v; do
    if [[ $__v =~ ^#.*$ ]]; then
    continue
    elif [[ $__v =~ ^$__p=.*$ ]]; then
      IFS=$'\n' read -d "" -ra __a <<< "${__v//=/$'\n'}"
      if [[ ! ${__a[1]} ]]; then
        echo "null"
        return 1
      else
        echo "${__a[1]}"
        return 0
      fi
    fi
  done < "$__f_digits"
  echo "null"
  return 1
}

edit_file() {
  if check_file "$1" --edit; then
    _err "edit: $__f_digits"
    "${EDITOR:-nano}" "$__f_digits"
  else
    local size1 size2
    _err "create new file: $__f_digits"
    cp "$__path_config/digits.template" "$__f_digits" 2> /dev/null || {
      _err "error: template file not found."
      return 1
    }
    size1="$(wc -c "$__f_digits")"
    _err "edit: $__f_digits"
    "${EDITOR:-nano}" "$__f_digits"
    size2="$(wc -c "$__f_digits")"
    [[ $size1 == "$size2" ]] && {
      rm "$__f_digits"
      _err "edit: no change, file $__f_digits removed."
    }
  fi
}

##    _    _
##  /|_o| |_
## / | ||_|_
## /FiLE

##  _   _  _
## / | / \/ |/
## \_|_\_/\_|\
## CLOCK

clock_geometry() {
  local term_h term_w

  if [[ ! ${__o[v]} || ${__o[w]} ]]; then
    ((__clock_h=__digit_h))
    [[ ${__o[N]} ]] && ((__clock_w=(__digit_w*4)+3))
    [[ ${__o[N]} ]] || ((__clock_w=(__digit_w*4)+2+__sep_w))
    [[ ${__o[S]} && ! ${__o[N]} ]] && ((__clock_w+=(__digit_w*2)+1+__sep_w))
    [[ ${__o[S]} && ${__o[N]} ]] && ((__clock_w+=(__digit_w*2)+2))
  else
    ((__clock_h=__digit_h*2+1))
    ((__clock_w=__digit_w*2+1))
    [[ ${__o[S]} ]] && ((__clock_h+=__digit_h+1))
  fi

  term_h="$(tput lines)"
  term_w="$(tput cols)"

  ((__clock_h>=term_h || __clock_w>=term_w)) && return 1

  ((__pos_y=(term_h-__clock_h)/2))
  ((__pos_x=(term_w-__clock_w)/2))
}

init_clock() {
  tput smcup
  tput civis
  stty -echo -icanon time 0 min 0

  [[ $__color_fg ]] && tput setaf "$__color_fg"
  [[ $__color_bg ]] && tput setab "$__color_bg"

  tput clear

  splash

  tput clear
}

redraw_clock() {
  if ! clock_geometry; then exit_clock "error: clock doesn't fit."; fi
  unset H1 H2 M1 M2 S1 S2 S p 
  unset __i_signal __i_alarm __i_timer
  unset __time __timezone __separator
  __u_date=1
  unset __s_date
  unset TH TM TS
  clear
}

erase_screen() {
  local y x h
  ((y=__pos_y-1))
  ((x=__pos_x-4))
  ((h=__clock_h+2))
  for ((i=y;i<y+h;i++)); do
    loc $((i)) $((x)); tput el
    if [[ ! ${__o[v]} ]]; then
      pause 0.0625
    else
      pause 0.03125
    fi
  done
  pause 0.5
}

splash() {
  local y x term_h term_w
  term_h="$(tput lines)"
  term_w="$(tput cols)"
  if [[ ! ${__o[v]} ]]; then
    local logo="-B!GT!ME-"
    ((y=(term_h-1)/2))
    ((x=(term_w-${#logo})/2))
    random_color
    loc $((y)) $((x))
    echo "$logo" | print_rainbow
  else
    local l1 l2 l3 l4
    l1="B!"; l2="-G"; l3="T!"; l4="ME"
    ((y=(term_h-4)/2))
    ((x=(term_w-2)/2))
    random_color
    loc $((y)) $((x))
    echo "$l1" | print_rainbow
    random_color
    loc $((y+1)) $((x))
    echo "$l2" | print_rainbow
    random_color
    loc $((y+2)) $((x))
    echo "$l3" | print_rainbow
    random_color
    loc $((y+3)) $((x))
    echo "$l4" | print_rainbow
  fi
  pause 0.25
  play_sound welcome
  pause 1
  loc $((y)) $((x))
  [[ ${__o[v]} ]] && tput el1
  [[ ! ${__o[v]} ]] && tput el
}

print_indicator() {
  local pos ind
  pos="$1"
  ind="$2"
  random_color
  loc $((__pos_y+pos)) $((__pos_x-4))
  echo "$ind" | print_rainbow
}

display_clock() {
  local h1 h2 m1 m2 s1 s2
  local Y X

  ((Y=__pos_y))
  ((X=__pos_x))

  smso() ( tput smso )
  rmso() ( tput rmso )

  h1=${_H:0:1}
  h2=${_H:1:1}
  m1=${_M:0:1}
  m2=${_M:1:1}
  s1=${_S:0:1}
  s2=${_S:1:1}

  _tick

  [[ $_a_set || $_t_set ]] && ((__digit_sel==0)) && smso
  [[ $h1 != "$H1" ]] && print_digit $((Y)) $((X)) "$h1"
  [[ $_a_set || $_t_set ]] && ((__digit_sel==0)) && rmso

  H1=$h1
  ((X+=__digit_w+1))

  [[ $_a_set || $_t_set ]] && ((__digit_sel==1)) && smso
  [[ $h2 != "$H2" ]] && print_digit $((Y)) $((X)) "$h2"
  [[ $_a_set || $_t_set ]] && ((__digit_sel==1)) && rmso

  H2=$h2

  if [[ ! ${__o[v]} && ! ${__o[N]} ]]; then
    ((X+=__digit_w))
    ((SX=X))
    ((X+=__sep_w))
  elif [[ ${__o[N]} ]]; then
    ((X+=__digit_w+1))
  else
    ((Y+=__digit_h+1))
    ((X=__pos_x))
  fi

  [[ $_a_set || $_t_set ]] && ((__digit_sel==2)) && smso
  [[ $m1 != "$M1" ]] && print_digit $((Y)) $((X)) "$m1"
  [[ $_a_set || $_t_set ]] && ((__digit_sel==2)) && rmso

  M1=$m1
  ((X+=__digit_w+1))

  [[ $_a_set || $_t_set ]] && ((__digit_sel==3)) && smso
  [[ $m2 != "$M2" ]] && print_digit $((Y)) $((X)) "$m2"
  [[ $_a_set || $_t_set ]] && ((__digit_sel==3)) && rmso

  M2=$m2

  if [[ ! ${__o[v]} ]]; then
    [[ ${__o[S]} ]] && {
      [[ ${__o[N]} ]] && ((X+=__digit_w+1))
      [[ ${__o[N]} ]] || ((X+=__digit_w))
    }
    [[ ${__o[S]} ]] || ((X+=__digit_w+1))
  else
    if [[ ${__o[S]} ]]; then
      ((Y+=__digit_h+1))
      ((X=__pos_x))
    else
      ((Y+=__digit_h-1))
      ((X+=__digit_w))
    fi
  fi

  [[ ${__o[b]} && $__display -eq 2 || $_a_set ]] && __tick_idx=0
  [[ ${__o[b]} && $__display -eq 3 && ! $_t_active || $_t_set ]] && __tick_idx=0

  if [[ ${__o[S]} ]]; then
    [[ ! ${__o[v]} && ! ${__o[N]} ]] && {
      [[ ! $__separator ]] && print_separator $((Y)) $((SX))
      [[ ! $__separator ]] && print_separator $((Y)) $((X))
      ((X+=__sep_w))
    }

    [[ $s1 != "$S1" ]] && print_digit $((Y)) $((X)) "$s1"

    S1=$s1
    ((X+=__digit_w+1))

    [[ $s2 != "$S2" ]] && print_digit $((Y)) $((X)) "$s2"

    S2=$s2
    ((X+=__digit_w+1))

  elif [[ ! ${__o[s]} && ! ${__o[v]} && ! ${__o[N]} ]]; then
    [[ ! $__separator ]] && print_separator $((Y)) $((SX))
  fi

  [[ ${__o[s]} ]] || [[ $__display -eq 3 || $_t_set ]] && [[ ! ${__o[S]} ]] && {
    if [[ ! ${__o[v]} && ! ${__o[N]} ]]; then
      [[ ! $__separator ]] && print_separator $((Y)) $((SX))
      if [[ $S1 != "$s1" ]]; then
        loc $((Y)) $((X))
      else
        loc $((Y)) $((X+1))
      fi
    else
      if [[ $S1 != "$s1" ]]; then
        loc $((Y)) $((__pos_x+__clock_w+1))
      else
        loc $((Y)) $((__pos_x+__clock_w+2))
      fi
    fi

    random_color
    [[ $S1 != "$s1" ]] && echo "$s1" | print_rainbow
    S1="$s1"

    random_color
    [[ $S2 != "$s2" ]] && echo "$s2" | print_rainbow
    S2="$s2"

    S="$_S"
  }

  [[ ! ${__o[b]} || $__display -eq 2 || $_a_set ]] && __separator=1

  [[ ! ${__o[s]} ]] && [[ $__display -ne 3 || ! $_t_set ]] && [[ ! ${__o[S]} ]] && {
    [[ ! $S ]] && { loc $((Y)) $((X)); tput el; }
    unset S
  }

  [[ $_p ]] && {
    [[ ${__o[v]} && ! ${__o[S]} ]] && ((X++))
    loc $((__pos_y+__digit_h-1)) $((X))
    random_color
    [[ $p != "$_p" ]] && echo "$_p" | print_rainbow
    p="$_p"
  }

  [[ ${__o[f]} && $p ]] && {
    loc $((__pos_y+__digit_h-1)) $((X))
    tput el
    unset p
  }
}

exit_clock() {
  [[ $1 == "--quit" ]] && { erase_screen; shift; }
  tput cnorm
  tput rmcup
  stty sane
  [[ $TERM =~ ^tmux.*$ ]] && echo -en "\033]0;$(hostname)\007"
  [[ $1 ]] && _err "$1" && exit 1
  _err "-- bye!"
  exit 0
}


##    _   _  _
##  // | / \/ |/
## / \_|_\_/\_|\
## /CLOCK

## ___     _ _    ____
##  |o|\/||_| \ /\ ||_
##  |||  ||_|_//--\||_
## TiMEDATE

declare -i __u_date=1

exec {pause_fd}<> <(:)
pause() ( read -rt "$1" -u $pause_fd )

_time() ( printf "%($1)T\\n" "-1" )

_split_time()  { IFS=$'\n' read -d "" -ra __T_timedate <<< "${1//:/$'\n'}"; }

_format_date() ( date -d "$1"  "+$2" 2> /dev/null )

_from_epoch()  ( date -d "@$1" "+$2" 2> /dev/null )

_to_epoch()    ( date -d "$1"  "+%s" 2> /dev/null )

_tick()        { ((__tick_idx=EPOCHSECONDS%2==0?0:1)); }

_hms_to_ttime() {
  local H M S __w __d __m
  _split_time "$1:$(_time "%a:%d:%m")"
  H="${__T_timedate[0]}"
  M="${__T_timedate[1]}"
  S="${__T_timedate[2]}"
  __w="${__T_timedate[3]}"
  __d="${__T_timedate[4]}"
  __m="${__T_timedate[5]}"
  printf "%s:  :%s:%s:%s:%s:%s:%s" "$H" "$H" "$M" "$S" "$__w" "$__d" "$__m"
}

_sec_to_hms() {
  local T H M S __w __d __m
  T=$1
  ((H=T/3600))
  ((M=(T%3600)/60))
  ((S=T%60))
  _split_time "$(_time "%a:%d:%m")"
  __w="${__T_timedate[0]}"
  __d="${__T_timedate[1]}"
  __m="${__T_timedate[2]}"
  printf "%02d:  :%02d:%02d:%02d:%s:%s:%s" "$H" "$H" "$M" "$S" "$__w" "$__d" "$__m"
}

display_time() {
  ((__display==1)) || return 1
  _split_time "$(LC_TIME=C _time "$__format")"
  return 0
}

parse_time() {
  if [[ ${__o[f]} ]]; then
    _H="${__T_timedate[2]}"  # hour (00-23)
    [[ $_p ]] && unset _p
  else
    _H="${__T_timedate[0]}"  # hour (01-12)
    _p="${__T_timedate[1]}"  # am/pm
    case $_p in
      AM) [[ ${__i[am]} ]] && _p="${__i[am]}" ;;
      PM) [[ ${__i[pm]} ]] && _p="${__i[pm]}"
    esac
  fi
  _M="${__T_timedate[3]}"    # minutes (00-59)
  _S="${__T_timedate[4]}"    # seconds (00-59)
  _Z="${__T_timedate[8]}"    # timezone (+0000)
}

parse_date() {
  W="${__T_timedate[5]:0:2}" # weekday (MO-SU)
  W="${W^^}"
  D="${__T_timedate[6]}"     # day (01-31)
  m="${__T_timedate[7]}"     # month (01-12)
  __date="$W $m-$D"
}

manage_hourly_signal() {
  [[ ${__o[q]} ]] && return 1

  [[ ${__o[i]} && ! $_a_ring && ! $_t_ring ]] && {
    case $__display in
      1  ) [[ $_M == "00" && $_S == "00" ]] && play_sound beep ;;
      2-3) local mm ss; mm="$(_time "%M")"; ss="$(_time "%S")"; [[ $mm == "00" && $ss == "00" ]] && play_sound beep
    esac
  }
  [[ ! $__i_signal ]] && {
    [[ ${__o[i]} ]] && { ((__display==1)) && print_indicator 0 " ${__i[i]} "; }
    [[ ${__o[i]} ]] || { ((__display==1)) && print_indicator 0 "   "; }
    __i_signal=1
  }
}

toggle_hourly_signal() {
  [[ ${__o[q]} ]] && return 1

  ((__display==1)) || return 1

  [[ ${__o[i]} ]] && {  unset __o["i"] __i_signal; return 0; }
  [[ ${__o[i]} ]] || { __o[i]=1; unset __i_signal; return 0; }
}

erase_clock_line() {
  loc $((__pos_y+__digit_h)) $((__pos_x))
  tput el
  unset __time __timezone
}

update_date() {
  [[ ! ${__o[d]} ]] && return 1
  [[ $_H == "00" ]] || [[ $_H == "12" && $_p == "${__i[am]}" ]] && [[ $_M == "00" && $_S == "00" ]] && {
    __u_date=1
    return 0
  }
  return 0
}

print_date() {
  [[ ! ${__o[d]} ]] && return 1
  [[ ! $__u_date ]] && return 1
  [[ $__s_date == "$__date" ]] && { unset __u_date; return 1; }
  local y x
  unset __u_date
  [[ ${__o[v]} ]] && {
    ((y=__pos_y))
    ((x=__pos_x+__clock_w+1))
    loc $((y)) $((x))
    random_color
    echo "$W" | print_rainbow
    loc $((y+1)) $((x))
    random_color
    echo "$m" | print_rainbow
    loc $((y+2)) $((x))
    random_color
    echo "$D" | print_rainbow
    __s_date="$__date"
    return 0
  }
  ((y=__pos_y-1))
  ((x=__pos_x))
  loc $((y)) $((x))
  random_color
  echo "$__date" | print_rainbow
  __s_date="$__date"
  return 0
}

print_time() {
  local t
  [[ ${__o[f]} ]] && t="$(_time "%H:%M")" || t="$(LC_TIME=C _time "%I:%M %p")"
  [[ $t != "$__time" ]] && echo -ne "\033]0;bigtime: $t\007"
  if ((__display>1)); then
    [[ $t != "$__time" ]] && {
      random_color
      loc $((__pos_y+__digit_h)) $((__pos_x))
      echo "$t" | print_rainbow
      __time="$t"
    }
    return 0
  fi
  return 1
}

print_timezone() {
  [[ ! ${__o[z]} ]] && return 1
  if ((__display==1)) && [[ ! $__timezone ]]; then
    loc $((__pos_y+__digit_h)) $((__pos_x))
    printf "%s" "$_Z"
    __timezone=1
    return 0
  fi
  return 1
}

toggle_ampm() {
  ((__display==1)) && {
    [[ ${__o[f]} ]] && { unset __o["f"]; return 0; }
    [[ ${__o[f]} ]] || { __o[f]=1; return 0; }
  }
  ((__display==2)) && { toggle_alarm_ampm || return 1; }
  return 1
}

##  ___     _ _    ____
##  /|o|\/||_| \ /\ ||_
## / |||  ||_|_//--\||_
## /TiMEDATE

##            _
##  /\ |  /\ |_)|\/|
## /--\|_/--\| \|  |
## ALARM

set_alarm() {
  [[ $1 == "cmdline" ]] && {
    [[ $_a_time == "now" ]] && {
      _a_ring=1
      _a_ring_dur=1
      unset _a_time
      unset __o["a"]
      return 0
    }
    local f="^[0-2]?[0-9]:[0-5][0-9][[:space:]]?(AM|am|PM|pm)?$"
    [[ $_a_time =~ $f ]] || return 1
  }
  if [[ ${__o[f]} ]]; then
    _a_time="$(_format_date "$_a_time" "%H:%M:%S")" || {
      play_sound error
      return 1
    }
  else
    _a_time="$(LC_TIME=C _format_date "$_a_time" "%I:%M:%S %p")" || {
      play_sound error
      return 1
    }
  fi
  __T_a_sec="$(_to_epoch "$_a_time")" || return 1
  ((__T_a_sec<EPOCHSECONDS)) && ((__T_a_sec+=86400))
  return 0
}

activate_alarm() {
  [[ ${__o[a]} && $__T_a_sec ]] && {
    ((_a_sec=__T_a_sec))
    unset __T_a_sec
    return 0
  }
  return 1
}

set_snooze() {
  # snooze duration 5-15 minutes (default: 9 minutes)
  [[ $1 == "--default" ]] && {
    _snooze_dur="${_snooze_dur:-540}"
    return 0
  }
  _snooze_dur=$1
  [[ $_snooze_dur =~ ^[0-9]?[0-9]$ ]] || return 1
  ((_snooze_dur<5 || _snooze_dur>15)) && return 1
  ((_snooze_dur*=60))
  return 0
}

display_alarm() {
  ((__display!=2)) && return 1
  if [[ $_a_set ]]; then
    _split_time "$(LC_TIME=C _from_epoch "$__T_a_sec" "$__format")"
  elif [[ $_a_sec ]]; then
    _split_time "$(LC_TIME=C _from_epoch "$_a_sec" "$__format")"
  fi
  return 0
}

cancel_alarm() {
  [[ $__changed ]] && {
    ((__T_a_sec=_a_sec))
    local alarm
    alarm="$(LC_TIME=C _from_epoch "$__T_a_sec" "$__format")"
    _split_time "$alarm"
    parse_time
    [[ ${__o[f]} ]] && _a_time="$_H:$_M:$_S"
    [[ ${__o[f]} ]] || _a_time="$_H:$_M:$_S $_p"
  }
  unset _a_set __changed
  unset __digit_sel
  unset H1 H2 M1 M2
  return 0
}

toggle_alarm() {
  [[ ${__o[q]} ]] && return 1

  [[ $_a_snooze ]] && ((__display==1)) && { # snooze deactivate
    unset _a_snooze _a_snooze_dur
    unset _a_ring _a_ring_dur
    unset __i_alarm
    return 0
  }

  ((__display==2)) && { # alarm display mode
    [[ $_a_set ]] && { # alarm set mode
      [[ $__changed ]] && { # confirm
        __o[a]=1
        play_sound confirm
        activate_alarm
        unset __changed _a_set __digit_sel H1 H2 M1 M2
        toggle_display 1
        return 1
      }
      [[ $__changed ]] || { # discard
        unset __changed _a_set __digit_sel H1 H2 M1 M2
        toggle_display 1
        return 0
      }
    }
    set_alarm
    _a_set=1
    toggle_display 2
    return 0
  }

  ((__display!=1)) && return 1

  [[ ${__o[a]} ]] && { # alarm off
    unset __o["a"]
    unset __i_alarm
    return 0
  }
  [[ ! ${__o[a]} && $_a_sec ]] && { # alarm on
    __o[a]=1
    unset __i_alarm
    return 0
  }
  [[ ! ${__o[a]} && ! $_a_sec ]] && { # new alarm
    _a_time="00:00:00"; set_alarm
    _a_set=1
    toggle_display 2
    return 0
  }
  return 1
}

toggle_alarm_ampm() {
  [[ $_a_set ]] && [[ ! ${__o[f]} ]] && {
    play_sound key
    if [[ $_a_time =~ ^.*AM$ ]]; then _a_time="${_a_time/AM/PM}"
    else _a_time="${_a_time/PM/AM}"; fi
    __changed=1
    set_alarm
    __u_date=1
    return 0
  }
  return 1
}

manage_alarm() {
  [[ ${__o[q]} ]] && return 1
  
  [[ ${__o[a]} ]] && ((__display!=2)) && [[ $EPOCHSECONDS == "$_a_sec" ]] && {
    local t
    [[ ${__o[f]} ]] && t="$(_time "%H:%M")" || t="$(LC_TIME=C _time "%I:%M %p")"
    notify --alarm "$t"
    ((_a_sec+=86400))
    _a_ring=1; _a_ring_dur=0
    _a_snooze=1; _a_snooze_dur=0
    unset __i_alarm
  }
  [[ ${__o[a]} ]] && ((_a_snooze_dur==_snooze_dur)) && {
    _a_ring=1
    _a_ring_dur=0
    _a_snooze_dur=0
    unset __i_alarm
  }
  [[ $_a_ring ]] && ((__tick_idx==1)) && play_sound alarm
  [[ $_a_ring ]] && ((_a_ring_dur++))
  [[ $_a_snooze ]] && ((_a_snooze_dur++))
  ((_a_ring_dur==30)) && unset _a_ring _a_ring_dur __i_alarm
 
  [[ ! $__i_alarm ]] && {
    [[ ${__o[a]} ]] && {
      ((__display==2)) && { [[ $_a_set ]] && print_indicator 1 " ${__i[a]}>"; }
      ((__display==2)) && { [[ $_a_set ]] || print_indicator 1 ">${__i[a]} "; }
      ((__display!=2)) && {
        [[ $_a_ring ]] && ((__tick_idx==1)) && { print_indicator 1 " ${__i[a]} "; return 0; }
        [[ $_a_ring ]] && ((__tick_idx==0)) && { print_indicator 1 "   "; return 0; }
        [[ ! $_a_ring ]] && [[ $_a_snooze ]] && print_indicator 1 " ${__i[o]} "
        [[ ! $_a_ring ]] && [[ ! $_a_snooze ]] && print_indicator 1 " ${__i[a]} "
      }
    }
    [[ ${__o[a]} ]] || print_indicator 1 "   "
    __i_alarm=1
    return 0
  }
  [[ ! ${__o[a]} ]] && return 1
}

##             _
##  //\ |  /\ |_)|\/|
## //--\|_/--\| \|  |
## /ALARM

## ___     _ _
##  |o|\/||_|_)
##  |||  ||_| \
## TiMER

set_timer() {
  [[ $_t_time =~ ^[0-2]?[0-9]:[0-5][0-9] ]] && {
    [[ $_t_time == "00:00" || $_t_time == "0:00" ]] && return 1
    _t_time="$(_format_date "$_t_time" "%H:%M:%S")" || return 1
    return 0
  }
  return 1
}

activate_timer() {
  [[ ! ${__o[t]} ]] && return 1
  [[ ! ${__o[t]} ]] && return 1
  local H M
  _split_time "$_t_time"
  H="${__T_timedate[0]}"
  M="${__T_timedate[1]}"
  _t_sec="$(_format_date "now + $H hours $M minutes" "%s")"
  unset __T_t_sec
  _t_active=1
  unset __i_timer
  return 0
}

reset_timer() {
  [[ ${__o[q]} ]] && return 1
  unset __o["t"] _t_active _t_time _t_sec _t_time_left
  unset _t_ring _t_ring_dur __i_timer
  erase_timer_line
  return 0
}

display_timer() {
  ((__display!=3)) && return 1
  if [[ $_t_set ]]; then
    _split_time "$(LC_TIME=C _hms_to_ttime "$_t_time")"
  elif [[ $_t_active ]]; then
    _split_time "$(LC_TIME=C _sec_to_hms "$_t_time_left")"
    unset TH TM TS
  fi
}

print_timer() {
  [[ ${__o[q]} ]] && return 1
  ((__display != 3)) && [[ $_t_active ]] && {
    local t h m s y x
    _split_time "$(LC_TIME=C _sec_to_hms "$_t_time_left")"
    h="${__T_timedate[0]}"
    m="${__T_timedate[3]}"
    s="${__T_timedate[4]}"

    [[ ${__o[v]} ]] || {
      [[ $h != "00" ]] && t="$h:$m:$s"
      [[ $h == "00" ]] && t="   $m:$s"
      [[ $h == "00" ]] && [[ $m == "00" ]] && t="     :$s"
      ((y=__pos_y+__clock_h)); ((x=__pos_x+__clock_w-${#t}))
      loc $((y)) $((x))
      echo "$t" | print_rainbow
      return 0
    }
    [[ ${__o[v]} ]] && {
      ((y=__pos_y+__clock_h-__digit_h)); ((x=__pos_x-3))
      loc $((y)) $((x)); [[ $TH != "$h" ]] && { echo "$h" | print_rainbow; TH=$h; }; ((y++))
      loc $((y)) $((x)); [[ $TM != "$m" ]] && { echo "$m" | print_rainbow; TM=$m; }; ((y++))
      loc $((y)) $((x)); [[ $TS != "$s" ]] && { echo "$s" | print_rainbow; TS=$s; }
      return 0
    }
  }
  return 1
}

erase_timer_line() {
  [[ ${__o[q]} ]] && return 1
  local y x
  [[ ${__o[v]} ]] || {
    ((y=__pos_y+__clock_h)); ((x=__pos_x+__clock_w-8))
    loc $((y)) $((x)); tput el
  }
  [[ ${__o[v]} ]] && {
    ((y=__pos_y+__clock_h-__digit_h)); ((x=__pos_x-3))
    loc $((y)) $((x)); echo "  "; ((y++))
    loc $((y)) $((x)); echo "  "; ((y++))
    loc $((y)) $((x)); echo "  ";
  }
  unset TH TM TS
}

toggle_timer() {
  [[ ${__o[q]} ]] && return 1

  ((__display==3)) && { # timer display mode
    [[ $_t_set ]] && { # timer set mode
      [[ $__changed ]] && { # confirm
        __o[t]=1
        play_sound confirm
        activate_timer
        unset __changed _t_set __digit_sel H1 H2 M1 M2
        toggle_display 1
        return 1
      }
      [[ $__changed ]] || { # discard
        unset __changed _t_set __digit_sel H1 H2 M1 M2
        toggle_display 1
        return 0
      }
    }
    reset_timer
    _t_time="00:00:00"
    set_timer
    _t_set=1
    toggle_display 3
    return 0
  }

 ((__display!=1)) && return 1

  [[ ${__o[t]} ]] && { # timer off
    unset __o["t"]
    reset_timer
    return 0
  }
  [[ ! ${__o[t]} && $_t_sec ]] && { # timer on
    __o[t]=1
    unset __i_timer
    return 0
  }
  [[ ! ${__o[t]} && ! $_t_sec ]] && { # new timer
    _t_time="00:00:00"
    _t_set=1
    toggle_display 3
    return 0
  }
  return 1
}

timer_elapse() {
  [[ ! $_t_active ]] && return 1
  ((_t_time_left=_t_sec-EPOCHSECONDS))
  ((_t_time_left=_t_time_left>0?_t_time_left:0))
  return 0
}

cancel_timer() {
  unset _t_set __changed
  unset __digit_sel
  unset H1 H2 M1 M2
  return 0
}

manage_timer() {
  [[ ${__o[q]} ]] && return 1

  timer_elapse

  [[ $_t_active && ! $_t_ring ]] && {
    ((_t_time_left==0)) && {
      notify --timer "Time out"
      _t_ring=1; _t_ring_dur=0; unset __i_timer
      ((__display==3)) && toggle_display 1
    }
  }

  [[ $_t_ring  && ! $_a_ring ]] && ((__tick_idx==1)) && play_sound timer
  [[ $_t_ring ]] && ((_t_ring_dur++))
  ((_t_ring_dur==15)) && reset_timer

  [[ ! $__i_timer ]] && {
    [[ ${__o[t]} ]] && {
      ((__display==3)) && { [[ $_t_set ]] && print_indicator 2 " ${__i[t]}>"; }
      ((__display==3)) && { [[ $_t_set ]] || print_indicator 2 ">${__i[t]} "; }
      ((__display!=3)) && {
        [[ $_t_ring ]] && ((__tick_idx==1)) && { print_indicator 2 " ${__i[t]} "; return 0; }
        [[ $_t_ring ]] && ((__tick_idx==0)) && { print_indicator 2 "   "; return 0; }
        [[ ! $_t_ring ]] && print_indicator 2 " ${__i[t]} "
      }
    }
    [[ ${__o[t]} ]] || print_indicator 2 "   "
    __i_timer=1
    return 0
  }
  [[ ! ${__o[t]} ]] && return 1
  return 0
}

##  ___     _ _
##  /|o|\/||_|_)
## / |||  ||_| \
## /TiMER

##
## |\/| /\ o|\ |
## |  |/--\|| \|
## MAiN

# shellcheck disable=SC2155
declare -r progname="$(basename "$0")"
declare -r PROGNAME="${progname^^}"
declare -r __version="2.2"

_opts=$(LC_ALL=C getopt                     \
  --long "alarm:"                           \
  --long "background:"                      \
  --long "big-seconds"                      \
  --long "blink"                            \
  --long "date"                             \
  --long "edit:"                            \
  --long "file:"                            \
  --long "foreground:"                      \
  --long "help"                             \
  --long "list-colors"                      \
  --long "list-files"                       \
  --long "no-separator"                     \
  --long "preview"                          \
  --long "quiet"                            \
  --long "rainbow"                          \
  --long "random"                           \
  --long "signal"                           \
  --long "small-seconds"                    \
  --long "snooze:"                          \
  --long "timer:"                           \
  --long "timezone"                         \
  --long "version"                          \
  --long "vertical"                         \
  --options "a:B:Sbde:fF:hClNwqrniso:t:zvV" \
  --name "$progname"                        \
  -- "$@"                                   \
) || exit 1

eval set -- "$_opts"

declare -A __o

while :
do
  case $1 in
    -a | --alarm        ) [[ ${__o[q]} ]] && { shift 2; continue; }; __o[a]=1; _a_time="$2"; shift 2 ;;
    -B | --background   ) set_color --bg "$2" || { _err "error: invalid background color."; exit 1; }; shift 2 ;;
    -b | --blink        ) [[ ${__o[v]} ]] && { shift; continue; }; __o[b]=1; shift ;;
    -C | --list-colors  ) list_colors; exit 0 ;;
    -d | --date         ) __o[d]=1; shift ;;
    -e | --edit         ) edit_file "$2"; exit 1 ;;
    -F | --foreground   ) set_color --fg "$2" || { _err "error: invalid foreground color."; exit 1; }; shift 2 ;;
    --file              ) check_file "$2" || { _err "error: --file $__f_digits not found."; exit 1; }; shift 2 ;;
    -f                  ) __o[f]=1; shift ;;
    -h | --help         ) _help; exit 0 ;;
    -i | --signal       ) [[ ${__o[q]} ]] && { shift; continue; }; __o[i]=1; shift ;;
    -l | --list-files   ) list_files || { _err "error: no digits files found."; exit 1; }; exit 0 ;;
    -N | --no-separator ) [[ ${__o[v]} ]] && { shift; continue; }; unset __o["b"]; __o[N]=1; shift ;; 
    -n | --random       ) __o[n]=1; unset __o["r"] _color_fg; shift ;;
    -o | --snooze       ) [[ ${__o[q]} ]] && { shift 2; continue; }; set_snooze "$2" || { _err "error: invalid snooze duration."; exit 1; }; shift 2 ;;
    -q | --quiet        ) __o[q]=1; unset __o["a"] _a_time __o["t"] _t_time __o["i"]; shift ;;
    -r | --rainbow      ) __o[r]=1; unset __o["n"] _color_fg; shift ;;
    -S | --big-seconds  ) __o[S]=1; unset __o["s"]; shift ;;
    -s | --small-seconds) __o[s]=1; unset __o["S"]; shift ;;
    -t | --timer        ) [[ ${__o[q]} ]] && { shift 2; continue; }; __o[t]=1; _t_time="$2"; shift 2 ;;
    -V | --version      ) _version; exit 0 ;;
    -v | --vertical     ) __o[v]=1; unset __o["b"] __o["N"]; shift ;;
    -w | --preview      ) [[ ! $__f_digits ]] && { _err "error: --preview: missing --file option."; exit 1; }; __o[w]=1; shift ;;
    -z | --timezone     ) __o[z]=1; shift ;;
    --                  ) shift; break ;;
    *                   ) [[ ! $1 ]] && break; _err "error: invalid option '$1'."; exit 1
  esac
done

##  _   _____
## | \o/__o|
## |_/|\_|||
## DiGiT

print_digit() {
  local y x d i D
  y=$1 x=$2; d=$3
  shift 3
  [[ ${__o[n]} ]] && random_color
  for ((i=0;i<__digit_h;i++)); do
    [[ ${__o[r]} ]] && random_color
    D=$"__d${d}[$i]"
    tput cup $((y)) $((x))
    echo $"${!D}" | print_rainbow
    ((y++))
  done
}

print_separator() {
  local y x i ba s
  y=$1; x=$2
  shift 2
  [[ ${__o[n]} ]] && random_color
  for ((i=0;i<__digit_h;i++)); do
    [[ ${__o[r]} ]] && random_color
    [[ ${__o[b]} ]] && {
      ba=("${__d_s[$i]}" "${__d_k[$i]}")
      s="${ba[$__tick_idx]}"
    } || s="${__d_s[$i]}"
    loc $((y)) $((x))
    echo "$s" | print_rainbow
    ((y++))
  done
}

print_rainbow() {
  local line
  [[ ! ${__o[r]} && ! ${__o[n]} ]] && {
    while IFS= read -r line; do 
      printf "%s" $"$line"
    done
    return
  }
  local len i a
  while IFS= read -r line; do
    len=${#line}
    for ((i=0;i<len;i++)); do
      a="${line:$((i)):1}"
      [[ $a == " " ]] && { printf "%s" $"$a"; continue; }
      printf "\033[38;5;%dm%s" "$__color" $"$a"
    done
    unset __color
  done
}

select_digit() {
  case $1 in
    next)
      [[ $_a_set || $_t_set ]] && {
        case $__digit_sel in
          0) unset H1 H2 ;;
          1) unset H2 M1 ;;
          2) unset M1 M2 ;;
          3) unset M2 H1
        esac
        ((__digit_sel=__digit_sel==3?0:__digit_sel+1))
        play_sound digit
      }
    ;;
    prev)
      [[ $_a_set || $_t_set ]] && {
        case $__digit_sel in
          0) unset H1 M2 ;;
          1) unset H1 H2 ;;
          2) unset H2 M1 ;;
          3) unset M1 M2
        esac
        ((__digit_sel=__digit_sel==0?3:__digit_sel-1))
        play_sound digit
      }
  esac
}

digit_input() {
  ! [[ $_a_set || $_t_set ]] && return 1
  local offset
  case $__digit_sel in
    [0-1]) ((offset=__digit_sel)) ;;
    [2-3]) ((offset=__digit_sel+1))
  esac
  [[ $_a_set ]] && {
    local saved_alarm="$_a_time"
    _a_time="${_a_time:0:$((offset))}${1}${_a_time:$((offset+1))}"
    if set_alarm; then
      __changed=1
      __u_date=1
      select_digit next
    else
      play_sound error
      _a_time="$saved_alarm"
      set_alarm
      return 1
    fi
    return 0
  }
  [[ $_t_set ]] && {
    local saved_timer="$_t_time"
    _t_time="${_t_time:0:$((offset))}${1}${_t_time:$((offset+1))}"
    if set_timer; then
      __changed=1
      select_digit next
    else
      play_sound error
      _t_time="$saved_timer"
      set_timer
      return 1
    fi
    return 0
  }
}

[[ ! -a "$__f_digits_default" ]] && { _err "error: $__f_digits_default not found."; exit 1; } 

__f_digits="${__f_digits:-$__f_digits_default}"

__digit_h="$(read_param "height")" || { _err "error: $__f_digits: missing 'height'."; exit 1; }
__digit_w="$(read_param "width")"  || { _err "error: $__f_digits: missing 'width'."; exit 1; }

__clock_layout="$(read_param "layout")"
if [[ ${__clock_layout,,} == "vertical" ]]; then __o["v"]=1
elif [[ ${__clock_layout,,} == "horizontal" ]]; then unset __o["v"]
fi
unset __clock_layout

__sec="$(read_param "seconds")"
case $__sec in
  big  ) __o[S]=1; unset __o["s"] ;;
  small) __o[s]=1; unset __o["S"] ;;
  null ) ;;
  *    ) _err "error: $__f_digits: invalid seconds value."; exit 1
esac
unset __sec

_ch="$(read_param "char")"
if [[ $_ch == "null" ]]; then
  __ch="∎"
  unset _ch
elif [[ ${#_ch} -ne 1 ]]; then
  _err "error: $__f_digits: 'char' must be 1 character."
  exit 1
elif [[ $_ch =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: 'char' cannot be a backslash escaped character."
  exit 1
elif [[ $_ch ]]; then
  __ch="$_ch"
  unset _ch
fi

_sp="$(read_param "space")"
if [[ $_sp == "null" ]]; then
  __sp=" "
  unset _sp
elif [[ ${#_sp} -ne 1 ]]; then
  _err "error: $__f_digits: 'space' must be 1 character."
  exit 1
elif [[ $_sp =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: 'space' cannot be a backslash escaped character."
  exit 1
elif [[ $_sp ]]; then
  __sp="$_sp"
  unset _sp
fi

_sep="$(read_param "separator")"
if [[ $_sep == "null" || ${_sep,,} =~ ^(false|no|off)$ ]]; then
  [[ ${__o[v]} ]] || { __o[N]=1; unset __o["b"]; }
fi
unset _sep

[[ ${__o[v]} || ${__o[N]} ]] || {
  __sep_w="$(read_param "sep_width")" || { _err "error: $__f_digits: missing 'sep_width'."; exit 1; }
}

_color_bg="$(read_param "background")"
[[ $_color_bg != "null" ]] && {
  set_color --bg "$_color_bg" || {
    _err "error: $__f_digits: invalid background color."
    exit 1
  }
}
unset _color_bg

_color_fg="$(read_param "foreground")"
[[ $_color_fg != "null" ]] && {
  case $_color_fg in
    rainbow)
      __o[r]=1
      unset __o["n"] __color_fg
      ;;
    random)
      __o[n]=1
      unset __o["r"] __color_fg
      ;;
    *)
      set_color --fg "$_color_fg" || {
        _err "error: $__f_digits: invalid foreground color."
        exit 1
      }
  esac
}
unset _color_fg

clock_geometry || { _err "error: clock doesn't fit."; exit 1; }

## MAKING DIGITS
for ((i=0;i<10;i++)); do
  _d="$(read_param "$i")" || { _err "error: $__f_digits: digit $i is missing."; exit 1; }
  IFS=$'\n' read -d "" -ra _d <<< "${_d//$';'/$'\n'}"
  ((${#_d[@]}!=__digit_h)) && { _err "error: $__f_digits: digit $i, height mismatch."; exit 1; }
  for ((j=0;j<__digit_h;j++)); do
    ((${#_d[$j]}!=__digit_w)) && { _err "error: $__f_digits: digit $i, width mismatch [col $((j+1))]."; exit 1; }
    _d[$j]="${_d[$j]//0/"$__sp"}"
    _d[$j]="${_d[$j]//1/"$__ch"}"
    declare -a "__d$i+=(\"${_d[$j]}\")"
  done
  unset _d
done

## MAKING SEPARATOR+BLANK
[[ ! ${__o[v]} && ! ${__o[N]} ]] && {
  ___p=("separator" "blank")
  for __p in "${___p[@]}"; do
    __v="$(read_param "$__p")"
    [[ $__v == "null" ]] && { _err "error: $__f_digits: missing $__p"; exit 1; }
    IFS=$'\n' read -d "" -ra __v <<< "${__v//$';'/$'\n'}"
    ((${#__v[@]}!=__digit_h)) && { _err "error: $__f_digits: $__p, height mismatch."; exit 1; }
    for ((i=0;i<__digit_h;i++)); do
      ((${#__v[$i]}!=__sep_w)) && { _err "error: $__f_digits: $__p, width mismatch [col $((i+1))].": exit 1; }
      __v[$i]="${__v[$i]//0/"$__sp"}"
      __v[$i]="${__v[$i]//1/"$__ch"}"
      case $__p in
        separator) declare -a "__d_s+=(\"${__v[$i]}\")" ;;
        blank    ) declare -a "__d_k+=(\"${__v[$i]}\")"
      esac
    done
    unset __v
  done
  unset __p ___p i j
}

unset __sp __ch

## INDICATORS
_i="$(read_param "am_indicator")"
[[ $_i != "null" ]] && __i[am]="$_i" || __i[am]="AM"

_i="$(read_param "pm_indicator")"
[[ $_i != "null" ]] && __i[pm]="$_i" || __i[pm]="PM"

_i="$(read_param "signal_indicator")"
if [[ $_i == "null" ]]; then
  __i[i]="*"
elif [[ ${#_i} -ne 1 ]]; then 
  _err "error: $__f_digits: signal indicator must be 1 character."
  exit 1
elif [[ $_i =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: signal indicator cannot be a backslash escaped character."
  exit 1
else
  __i[i]="$_i"
fi

_i="$(read_param "alarm_indicator")"
if [[ $_i == "null" ]]; then
  __i[a]="a"
elif [[ ${#_i} -ne 1 ]]; then 
  _err "error: $__f_digits: alarm indicator must be 1 character."
  exit 1
elif [[ $_i =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: alarm indicator cannot be a backslash escaped character."
  exit 1
else
  __i[a]="$_i"
fi

_i="$(read_param "snooze_indicator")"
if [[ $_i == "null" ]]; then
  __i[o]="z"
elif [[ ${#_i} -ne 1 ]]; then 
  _err "error: $__f_digits: snooze indicator must be 1 character."
  exit 1
elif [[ $_i =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: snooze indicator cannot be a backslash escaped character."
  exit 1
else
  __i[o]="$_i"
fi

_i="$(read_param "timer_indicator")"
if [[ $_i == "null" ]]; then
  __i[t]="t"
elif [[ ${#_i} -ne 1 ]]; then 
  _err "error: $__f_digits: timer indicator must be 1 character."
  exit 1
elif [[ $_i =~ \\[abcdefnrtv] ]]; then
  _err "error: $__f_digits: timer indicator cannot be a backslash escaped character."
  exit 1
else
  __i[t]="$_i"
fi

unset _i

##    _   _____
##  /| \o/__o|
## / |_/|\_|||
## /DiGiT

[[ ${__o[w]} ]] && { preview_file; exit 0; }

if [[ ${__o[a]} ]]; then set_alarm cmdline || { _err "error: invalid alarm time."; exit 1; }; fi
[[ ${__o[a]} ]] && activate_alarm
set_snooze --default

if [[ ${__o[t]} ]]; then set_timer || { _err "error: invalid timer duration."; exit 1; }; fi
[[ ${__o[t]} ]] && activate_timer

init_clock

trap 'exit_clock "-- interrupted by user."' INT QUIT
trap redraw_clock WINCH

while :
do
  # shellcheck disable=SC2162
  IFS= read KEY

  [[ $KEY ]] && __idle=0
  
  case $KEY in
    a    ) toggle_alarm && play_sound key ;;
    f    ) toggle_ampm && play_sound key ;;
    i    ) toggle_hourly_signal && play_sound key ;;
    j    ) select_digit next ;;
    k    ) select_digit prev ;;
    q    ) play_sound quit; exit_clock --quit ;;
    R    ) redraw_clock ;;
    t    ) toggle_timer && play_sound key ;;
    [0-9]) digit_input "$KEY" ;;
    " "  ) toggle_display && play_sound key
  esac

((__idle++))

[[ $__i_mode ]] && ((__idle==4)) && erase_display_line

((__idle==20 && __display!=1)) && { toggle_display 1; __idle=0; }

_sync

display_time || display_alarm || display_timer
manage_alarm
manage_timer
parse_time
parse_date
update_date && print_date
print_time || print_timezone
print_timer
manage_hourly_signal
display_clock

pause 0.5

done

##
##  /|\/| /\ o|\ |
## / |  |/--\|| \|
## /MAiN

##    _   _____     _
##  /|_)o/__ |o|\/||_
## / |_)|\_| |||  ||_
## /BiGTiME
