#! /usr/bin/env bash
######################################
#  _     _       _   _
# | |__ (_) __ _| |_(_)_ __ ___   ___
# | '_ \| |/ _` | __| | '_ ` _ \ / _ \
# | |_) | | (_| | |_| | | | | | |  __/
# |_.__/|_|\__, |\__|_|_| |_| |_|\___|
#          |___/ version 20200719-0.9
# ♥ ##################################

progname="$(basename "$0")"
PROGNAME="${progname^^}"
VERSION="20200719-0.9"

CONFIG_PATH="$HOME/.config/bigtime"
DIGITS_DEFAULT_FILE="$CONFIG_PATH/standard.digits"
BEEP_SOUND="$CONFIG_PATH/beep.wav"
ALARM_SOUND="$CONFIG_PATH/alarm.wav"
KEY_SOUND="$CONFIG_PATH/key.wav"
YES_SOUND="$CONFIG_PATH/confirm.wav"
ERROR_SOUND="$CONFIG_PATH/error.wav"

TERMH="$(tput lines)"
TERMW="$(tput cols)"

COLORS="$(tput colors)"

declare -i CLOCKH
declare -i CLOCKW

PRESETS=("█" " " "▮" " " "⦁" " " "◆" " " "▓" " " "♥" " " "⏺" " ")

__help() {

cat << 'EOB' >&2
BIGTIME - customizable digital clock

USAGE:
bigtime [OPTIONS] [VALUE]

OPTIONS:
-c, --char <char>        - character for digits (default is ∎)
-p, --space <char>       - character for whitespaces (default is " ")
-f                       - display time in 24h format
-s, --small-seconds      - show seconds (normal size)
-S, --big-seconds        - show seconds (big size)
-d, --date               - show date
-b, --blink              - blinking separators
-v, --vertical           - display clock vertically
-a, --alarm <time>       - set alarm
-i, --chime              - hourly chime
--file <filename>        - use a custom digits file (filename only)
-l, --list-files         - print available digits files
--preset <0..n>          - use predefined characters (override -c and -p options)
-P, --list-presets       - print preset characters
-F, --foreground <0..n>  - set foreground color
-B, --background <0..n>  - set background color
-C, --list-colors        - print available colors
-h, --help               - print this help message and exit
-V, --version            - print program's version and exit

KEYS BINDINGS:
a                        - toggle / set daily alarm / confirm (alarm setting mode)
h                        - toggle hourly time signal
j                        - select next digit (alarm setting mode)
k                        - select previous digit (alarm setting mode)
p                        - toggle 24h format / toggle AM/PM (alarm setting mode)
q                        - exit program
r                        - refresh screen
R                        - reset to default terminal colors
space                    - display or stop alarm

EOB
}

__err() {
  local color off
  off="$(tput sgr0)"

  case "$2" in
    -l) color="$(tput setaf 2)" ;;
    -n) color="$(tput setaf 3)" ;;
    -u) color="$(tput setaf 1)"
  esac

  ( >&2 echo -e "$progname: ${color}$2${off}" )
}

# compute clock size
clock_size() {
  local height width
  if [[ -z $_VERTICAL ]]; then
    ((height=dh))
    ((width=dw*4+sw+4))
    [[ $_BSEC ]] && ((width+=dw*2+sw+3))
  else
    ((height=dh*2+1))
    ((width=dw*2+2))
    [[ $_BSEC ]] && ((height+=dh))
  fi

  [[ $_DATE ]] && ((height+=1))

  ((CLOCKH=height))
  ((CLOCKW=width))
}

# redraw clock
redraw_clock() {
  _REDRAW=1
  TERMH="$(tput lines)"
  TERMW="$(tput cols)"
  if [[ $TERMH -le $CLOCKH || $TERMW -le $CLOCKW ]]; then
    exit_clock "error: clock doesn't fit"
  fi
  ((_y=(TERMH-CLOCKH)/2))
  ((_x=(TERMW-CLOCKW)/2))
  clear
  _REDRAW=0
}

exit_clock() {
  tput cnorm
  tput rmcup
  stty sane
  # update terminal title to default(?) within tmux (...)
  [[ $TERM =~ ^tmux.*$ ]] && echo -ne "\033]0;$(hostname)\007"
  [[ $1 ]] && __err -u "$1"
  __err -l "-- bye!"
  exit 1
}

! [[ -a "$DIGITS_DEFAULT_FILE" ]] && {
  __err -u "error: $DIGITS_DEFAULT_FILE not found"
    exit
}

# options

_opts=$(LC_ALL=C getopt                               \
  --long "help"                                       \
  --long "version"                                    \
  --long "preset:"                                    \
  --long "list-presets"                               \
  --long "char:"                                      \
  --long "space:"                                     \
  --long "small-seconds"                              \
  --long "big-seconds"                                \
  --long "date"                                       \
  --long "blink"                                      \
  --long "vertical"                                   \
  --long "alarm:"                                     \
  --long "chime"                                      \
  --long "file:"                                      \
  --long "list-files"                                 \
  --long "foreground:"                                \
  --long "background:"                                \
  --long "list-colors"                                \
  --options "h,V,c:,p:,f,s,S,d,,b,v,a:,i,F:,B:,P,C,l" \
  --name "$progname"                                  \
  -- "$@"                                             \
) || exit 1

eval set -- "$_opts"

# options parsing

while :; do
  case "$1" in
    -h | --help)
      __help
      exit 0
      ;;
    -V | --version)
      echo "$PROGNAME version $VERSION"
      exit 0
      ;;
    -c | --char)
      shift
      [[ ${#1} != 1 ]] && {
        __err -u "error: --char only 1 character allowed"
        exit 1
      }
      _CHR="$1"
      shift
      ;;
    -p | --space)
      shift
      [[ ${#1} != 1 ]] && {
        __err -u "error: --space only 1 character allowed"
        exit 1
      }
      _SPC="$1"
      shift
      ;;
    -f)
      _F24=1
      shift
      ;;
    -s | --small-seconds)
      unset _BSEC
      _SSEC=1
      shift
      ;;
    -S | --big-seconds)
      unset _SSEC
      _BSEC=1
      shift
      ;;
    -d | --date)
      _DATE=1
      shift
      ;;
    -b | --blink)
      _BLINK=1
      shift
      ;;
    -v | --vertical)
      unset _BLINK
      _VERTICAL=1
      shift
      ;;
    -a | --alarm)
      _ALARM=1
      shift
      _ALARM_TIME="$1"
      shift
      ;;
    -i | --chime)
      _BEEP=1
      shift
      ;;
    --file)
      shift
      [[ $1 =~ \.digits$ ]] && _FILE="$1" || _FILE="$1.digits"
      ! [[ -a "$CONFIG_PATH/$_FILE" ]] && {
        __err -u "error: --file $_FILE not found"
        exit 1
      } || _FILE="$CONFIG_PATH/$_FILE"
      shift
      ;;
    -l | --list-files)
      find "$CONFIG_PATH" -name "*.digits"
      exit 0
      ;;
    --preset)
      shift
      ((plen=(${#PRESETS[@]}-1)/2))
      if [[ $1 =~ [0-$plen] && $1 -ge 0 && $1 -le $plen ]]; then
        index=$1
        _CHR="${PRESETS[$((index*2))]}"
        _SPC="${PRESETS[$((index*2+1))]}"
        unset index
        shift
      else
        __err -u "error: --preset should be a numeric value between 0 and $plen"
        exit 1
      fi
      unset plen
      ;;
    -P | --list-presets)
      j=0
      for ((i=1;i<${#PRESETS[@]};((i+=2)))); do
        echo "$j: '${PRESETS[$((i-1))]}' '${PRESETS[$i]}'"
        ((j++))
      done
      exit 0
      ;;
    -F | --foreground)
      shift
      if [[ $1 =~ ^[0-9]+$ ]]; then
        if [[ $1 -ge 0 ]] && [[ $1 -le $((COLORS-1)) ]]; then
          _FG="$1"
        else
          __err -u "error: --foreground should be a numeric value between 0 and $((COLORS-1))"
          exit 1
        fi
      else
        __err -u "error: --foreground should be a numeric value between 0 and $((COLORS-1))"
        exit 1
      fi
      shift
      ;;
    -B | --background)
      shift
      if [[ $1 =~ ^[0-9]+$ ]]; then
        if [[ $1 -ge 0 ]] && [[ $1 -le $((COLORS-1)) ]]; then
          _BG="$1"
        else
          __err -u "error: --background should be a numeric value between 0 and $((COLORS-1))"
          exit 1
        fi
      else
        __err -u "error: --background should be a numeric value between 0 and $((COLORS-1))"
        exit 1
      fi
      shift
      ;;
    -C | --list-colors)
      tc="$(tput setaf 0)"
      ((maxcols=(TERMW/5)-1))
      col=0
      for ((i=0;i<COLORS;i++)); do
        on="$(tput setab $((i)))"
        off="$(tput sgr0)"
        printf "%s%s %03d %s" "$on" "$tc" "$i" "$off"
        ((col++))
        ((col>maxcols)) && { printf "\n"; col=0; }
      done
      echo
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      [[ -z $1 ]] && break
      __err -u "error: invalid option '$1'"
      exit 1
  esac
done

 readoption() {
  local file option
  file="$_FILE"
  while read -r line; do
    if [[ $line =~ ^$1=.*$ ]]; then
      IFS=$'\n' read -d "" -ra array <<< "${line//=/$'\n'}"
      if [[ -z ${array[1]} ]]; then
        echo "null"
        return 1
      else
        echo "${array[1]}"
        return 0
      fi
    fi
  done < "$file"
  echo "null"
  return 1
}

_FILE="${_FILE:-$DIGITS_DEFAULT_FILE}"

dh="$(readoption "height")"
dw="$(readoption "width")"
sw="$(readoption "sep_width")"

[[ $dw == "null" ]] && { __err -u "error: $_FILE: missing width value"; exit 1; }
[[ $dh == "null" ]] && { __err -u "error: $_FILE: missing height value"; exit 1; }
[[ $sw == "null" ]] && { __err -u "error: $_FILE: missing sep_width value"; exit 1; }

_SPC="${_SPC:-" "}"
_CHR="${_CHR:-"∎"}"

# read file and dynamically declare an array
# for each digit (_D0, _D1... _D9) where 1s are replaced by _CHR
# and 0s by _SPC

for ((i=0;i<10;i++)); do
  digit="$(readoption "$i")"
  [[ $digit == "null" ]] && { __err -u "error: $_FILE: missing digit $i"; exit 1; }
  IFS=$'\n' read -d "" -ra digit <<< "${digit//$';'/$'\n'}"
  ((${#digit[@]}!=dh)) && { __err -u "error: $_FILE: digit $i, height mismatch"; exit 1; }
  for ((j=0;j<dh;j++)); do
    ((${#digit[$j]}!=dw)) &&{ __err -u "error: $_FILE: digit $i, width mismatch: col $((j+1))"; exit 1; }
    digit[$j]=${digit[$j]//0/"$_SPC"}
    digit[$j]=${digit[$j]//1/"$_CHR"}
    declare -a "_D$i+=(\"${digit[$j]}\")"
  done
  unset digit
done

# same as above for separator and blank space
# (may have a different width than digits)

options=("separator" "blank")
for option in "${options[@]}"; do
  opt="$(readoption "$option")"
  [[ $opt == "null" ]] && { __err -u "error: $_FILE: missing $option"; exit 1; }
  IFS=$'\n' read -d "" -ra opt <<< "${opt//$';'/$'\n'}"
  # check whether height matches declared one
  ((${#opt[@]}!=dh)) && { __err -u "error: $option: height mismatch"; exit 1; }
  # replace 0s and 1s
  for ((i=0;i<dh;i++)); do
    # check whether width matches declared one
    ((${#opt[$i]}!=sw)) &&{ __err -u "error: $option, width mismatch: col $((i+1))"; exit 1; }
    opt[$i]=${opt[$i]//0/"$_SPC"}
    opt[$i]=${opt[$i]//1/"$_CHR"}
    case "$option" in
      separator) declare -a "_P+=(\"${opt[$i]}\")" ;;
      blank    ) declare -a "_W+=(\"${opt[$i]}\")"
    esac
  done
  unset opt
done

clock_size

if [[ $TERMH -le $CLOCKH || $TERMW -le $CLOCKW ]]; then
  __err -u "error: clock doesn't fit"
  exit 1
fi

# whenever several instances of bigtime are running
# this is a hack to synchronize them...
_sync() {
  declare -i n=1
  local N
  while ((n!=0)); do
    N="$(date "+%N")"
    n=${N:0:1}
    sleep 0.05
  done
}

print_digit() {
  local y x d D
  y=$1; x=$2; d=$3
  shift 3
  for ((i=0;i<dh;i++)); do
    D=$"_D"$d"[$i]"
    tput cup $((y)) $((x))
    printf $'%s' $"${!D}"
    ((y++))
  done
}

print_separator() {
  local y x blink_array sp
  y=$1; x=$2
  shift 2
  for ((i=0;i<dh;i++)); do
    [[ $_BLINK ]] && {
      blink_array=("${_P[$i]}" "${_W[$i]}")
      sp="${blink_array[$index]}"
    } || sp="${_P[$i]}"
    tput cup $((y)) $((x))
    printf "%s" "$sp"
    ((y++))
  done
}

reset_colors() {
  printf '\e[mR\n'
  redraw_clock
}

play_sound() {
  which aplay > /dev/null && {
    case "$1" in
      alarm  ) aplay --quiet "$ALARM_SOUND" & ;;
      beep   ) aplay --quiet "$BEEP_SOUND" & ;;
      key    ) aplay --quiet "$KEY_SOUND" & ;;
      error  ) aplay --quiet "$ERROR_SOUND" & ;;
      confirm) aplay --quiet "$YES_SOUND" &
    esac
  }
}

_make_date=0

tput smcup
tput civis
stty -echo -icanon time 0 min 0

[[ -n $_FG ]] && tput setaf "$_FG"
[[ -n $_BG ]] && tput setab "$_BG"

((_y=(TERMH-CLOCKH)/2))
((_x=(TERMW-CLOCKW)/2))

tput clear

trap 'exit_clock "-- interrupted by user"' INT QUIT
trap redraw_clock WINCH

set_alarm() {
  [[ $_ALARM ]] && {
    ALARM_TIME="$(date -d "$_ALARM_TIME" "+%s" 2> /dev/null)" || return 1
    _T="$(date "+%s")"
    ((ALARM_TIME<_T)) && ((ALARM_TIME+=86400))
    unset _T
  }
  return 0
}

set_alarm || exit_clock "invalid alarm time"

while :; do

  #shellcheck disable=SC2162
  IFS= read char
  # key bindings
  case "$char" in
    a)
      if [[ $_ALARM  && -z $_DALARM ]]; then
        # deactivate alarm
        unset _ALARM
        play_sound key
      elif [[ $ALARM_TIME && -z $_DALARM ]]; then
        # activate alarm
        _ALARM=1;
        play_sound key
      elif [[ -z $ALARM_TIME && -z $_DALARM ]]; then
          # new alarm setting mode
          current_alarm=""
          [[ $_F24 ]] && _ALARM_TIME="00:00:00" || _ALARM_TIME="12:00:00 AM"
          _DALARM=1
          _SET_ALARM=1
          _ALARM=1
          _DSELECT=0
          set_alarm
          play_sound key
          continue
      elif [[ $_DALARM ]]; then
          if [[ $_SET_ALARM ]]; then
          # quit alarm setting mode
            unset _SET_ALARM
            unset _DALARM
            unset _DSELECT
            tput cup $((_y+dh)) $((_x)); tput el
            play_sound confirm
            _make_date=0
          else
            # alarm setting mode
            _SET_ALARM=1
            _DSELECT=0
            tput cup $((_y+dh)) $((_x)); tput el
            play_sound key
          fi
      fi
      ;;
    h) [[ $_BEEP ]] && unset _BEEP || _BEEP=1; play_sound key ;;
    p)
      if [[ $_DSELECT && -z $_F24 ]]; then
        if [[ $_ALARM_TIME =~ .*AM$ ]]; then
          _ALARM_TIME="${_ALARM_TIME/AM/PM}"
        else
          _ALARM_TIME="${_ALARM_TIME/PM/AM}"
        fi
        if set_alarm; then play_sound key; else play_sound error; fi
      elif [[ -z $_F24  && -z $_DSELECT ]]; then
        [[ $_ALARM_TIME =~ .*(AM|PM)$ ]] && {
          _ALARM_TIME="$(date -d "$_ALARM_TIME" "+%H:%M:%S")"
          set_alarm
        }
        _F24=1; play_sound key
        tput cup $((_y+dh-1)) $((_x+CLOCKW)); tput el
        unset _AMPM
      elif [[ -z $_DSELECT ]]; then
        [[ $_ALARM_TIME =~ .*(AM|PM)$ ]] || {
          _ALARM_TIME="$(LC_TIME=C date -d "$_ALARM_TIME" "+%I:%M:%S %p")"
          set_alarm
        }
        unset _F24; play_sound key
      fi
      ;;
    q) play_sound key; exit_clock ;;
    r) play_sound key; redraw_clock ;;
    R) play_sound key; reset_colors -r ;;
    " ")
        if [[ $ALARM ]]; then
          unset ALARM
          play_sound key
          continue
        elif [[ $_ALARM ]]; then
            play_sound key
            if [[ $_DALARM ]]; then
              unset _DALARM
              unset _SET_ALARM
              ALARM_TIME="$current_alarm"
              [[ -z $ALARM_TIME ]] && unset _ALARM
              tput cup $((_y+dh)) $((_x)); tput el
              unset current_alarm
              unset _DSELECT
              _make_date=0
            else
              current_alarm="$ALARM_TIME"
              _DALARM=1;
            fi
        fi
        ;;
    $'\t' | j)
      [[ -z $_SET_ALARM ]] && continue
      ((_DSELECT=_DSELECT>2?0:_DSELECT+1)); play_sound key ;;
    k) ((_DSELECT=_DSELECT<1?3:_DSELECT-1)); play_sound key ;;
    [0-9])
      [[ -z $_SET_ALARM ]] && continue
      ((offset=_DSELECT>1?_DSELECT+1:_DSELECT))
      current="$_ALARM_TIME"
      _ALARM_TIME="${_ALARM_TIME:0:$((offset))}$char${_ALARM_TIME:$((offset+1))}"
      if set_alarm; then
        ((_DSELECT=_DSELECT>2?0:_DSELECT+1))
        play_sound key
      else
        play_sound error
        _ALARM_TIME="$current"
        set_alarm
      fi
      unset offset
      unset current
  esac
  
  [[ $_REDRAW == 1 ]] && continue


  # TIME and DATE
  # index | description
  # 0     | hour (01..12)
  # 1     | AM or PM
  # 2     | hour (00..23)
  # 3     | minute (00..59)
  # 4     | second (00..59)
  # 5     | seconds since the epoch
  # 6     | abbr. weekday name
  # 7     | day of month (01..31)
  # 8     | month (01..12)

  if [[ $_DALARM ]]; then
    _TIMEDATE="$(LC_TIME=C date -d "@$ALARM_TIME" "+%I:%p:%H:%M:%S:%s:%a:%d:%m")"
    _make_date=0
  else
    _TIMEDATE="$(LC_TIME=C date "+%I:%p:%H:%M:%S:%s:%a:%d:%m")"
  fi

  IFS=$'\n' read -d "" -ra TIMEDATE <<< "${_TIMEDATE//:/$'\n'}"
  unset _TIMEDATE

  # TIME
  # shellcheck disable=SC2015
  [[ $_F24 ]] && _H="${TIMEDATE[2]}" || { _H="${TIMEDATE[0]}"; _AMPM="${TIMEDATE[1]^^}"; }

  _M="${TIMEDATE[3]}"
  _S="${TIMEDATE[4]}"
  _A="${TIMEDATE[5]}"

  [[ $_H == "00"  && $_M == "00" && $_S == "00" ]] \
      || [[ $_H == 12 && $_AMPM == "AM" && $_M == "00" && $_S == "00" ]] && _make_date=0

  # DATE
  [[ $_DATE && $_make_date == 0 ]] && {
    W="${TIMEDATE[6]:0:2}"
    W="${W^^}"
    M="${TIMEDATE[8]}"
    D="${TIMEDATE[7]}"
    _date="${W^^} $M-$D"
    _make_date=1
  }

  unset TIMEDATE

  # change terminal title
  [[ $_T != "$_M" ]] && { _T="$_M"; echo -ne "\033]0;bigtime: $_H:$_M $_AMPM\007"; }

  # blink
  [[ $((${_S:1:1} % 2)) == 0 ]] && index=0 || index=1

  h1=${_H:0:1}
  h2=${_H:1:1}
  m1=${_M:0:1}
  m2=${_M:1:1}
  s1=${_S:0:1}
  s2=${_S:1:1}

  # SIZE DEBUG
  # tput cup 0 0
  # printf "x=%d y=%d ch=%d cw=%d dh=%d dw=%d sw=%d" "$_x" "$_y" "$CLOCKH" "$CLOCKW" "$dh" "$dw" "$sw"

  _sync
  
  # indicators
  tput cup $((_y)) $((_x-2)); [[ $_BEEP ]] && echo "$_CHR" || echo "$_SPC"
  tput cup $((_y+dh-1)) $((_x-2))
  if [[ $_ALARM ]]; then
    if [[ $ALARM && $index == 1 ]]; then
      printf " "
    elif [[ $_SET_ALARM ]]; then
        printf "%s" "$(tput smso)A$(tput rmso)"
        tput cup $((_y+dh)) $((_x))
        if [[ $_F24 ]]; then date "+%H:%M"; else LC_TIME=C date "+%I:%M %p"; fi
    elif [[ $_DALARM ]]; then
        printf "%s" "$(tput smul)A$(tput rmul)"
    else
      printf "A"
    fi
  else
      printf " "
  fi

  # beep
  [[ -z $ALARM && -z $_DALARM && $_BEEP && $_M == "00" && $_S == "00" ]] && play_sound beep

  # alarm
  [[ $_ALARM && -z $_DALARM ]] && [[ $ALARM_TIME == "$_A" ]] && {
    [[ $_F24 ]] && TIME="$(date -d "@$ALARM_TIME" "+%x - %X")" \
      || TIME="$(LC_TIME=C date -d "@$ALARM_TIME" "+%x - %I:%M:%S %p")"
    notify-send -u critical "$PROGNAME" "Alarm: $TIME"
    unset TIME
    # set new alarm for tomorrow
    ((ALARM_TIME+=86400))
    ALARM=1
  } 

  [[ $ALARM ]] && [[ $index == 0 ]] && play_sound alarm

  y=$_y x=$_x

  [[ $_date ]] && {
      if [[ $_VERTICAL ]]; then
        tput cup $((y))   $((x+CLOCKW)); printf "%s" "$W"
        tput cup $((y+1)) $((x+CLOCKW)); printf "%s" "$M"
        tput cup $((y+2)) $((x+CLOCKW)); printf "%s" "$D"
      else
        tput cup $((y-1)) $((x)); printf "%s" "$_date"
      fi
  }

  [[ $_SET_ALARM ]] && ((_DSELECT==0)) && tput smso
  print_digit $((y)) $((x)) "$h1"
  [[ $_SET_ALARM ]] && ((_DSELECT==0)) && tput rmso

  ((x+=dw+1))

  [[ $_SET_ALARM ]] && ((_DSELECT==1)) && tput smso
  print_digit $((y)) $((x)) "$h2";
  [[ $_SET_ALARM ]] && ((_DSELECT==1)) && tput rmso

  if [[ -z $_VERTICAL ]]; then
    ((x+=dw+1))
    ((sx=x))
    ((x+=sw+1))
  else
    ((y+=dh+1))
    x=$_x
  fi

  [[ $_SET_ALARM ]] && ((_DSELECT==2)) && tput smso
  print_digit $((y)) $((x)) "$m1"
  [[ $_SET_ALARM ]] && ((_DSELECT==2)) && tput rmso

  ((x+=dw+1))

  [[ $_SET_ALARM ]] && ((_DSELECT==3)) && tput smso
  print_digit $((y)) $((x)) "$m2"
  [[ $_SET_ALARM ]] && ((_DSELECT==3)) && tput rmso

  if [[ -z $_VERTICAL ]]; then
    ((x+=dw+1))
  else
    if [[ $_BSEC ]]; then
      ((y+=dh+1))
      x=$_x
    else
      ((y+=dh-1))
      ((x+=dw+1))
    fi
  fi

  if [[ $_BSEC ]]; then
    [[ -z $_VERTICAL ]] && {
      print_separator $((y)) $((sx))
      print_separator $((y)) $((x));
      ((x+=sw+1))
    }
    print_digit $((y)) $((x)) "$s1"
    ((x+=dw+1))
    print_digit $((y)) $((x)) "$s2"
    ((x+=dw+1))
  elif [[ -z $_SSEC && -z $_VERTICAL ]]; then
    print_separator $((y)) $((sx))
  fi

  [[ $_SSEC ]] && {
    if [[ -z $_VERTICAL ]]; then
      print_separator $((y)) $((sx))
      tput cup $((y)) $((x))
    else
      tput cup $((y)) $((_x+CLOCKW))
    fi
    printf "%s" "$_S"
  }

  [[ $_AMPM ]] && {
      tput cup $((_y+dh-1)) $((x))
      printf "%s" "$_AMPM"
  }
  
  sleep 0.5

done
